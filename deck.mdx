import { Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { vsDark, github, dracula } from "@code-surfer/themes";
import customTheme from './theme'

export const theme = customTheme;
import './styles.css'

import wcagDocsGif from './assets/wcagDocs.gif'
import designPatternsImage from './assets/designPatterns.png'
import alertDesignPattern from './assets/alertDesignPattern.png'
import alertExample1 from './assets/alertExample1.png'
import alertExample2 from './assets/alertExample2.png'
import alertExample3 from './assets/alertExample3.png'
import designPatternsIntro from './assets/designPatternsIntro.png'
import designPatternsIntro2 from './assets/designPatternsIntro2.png'
import designPatternsIntro3 from './assets/designPatternsIntro3.png'
import designPatternsMenuExample from './assets/designPatternsMenuExample.png'
import keyboardNav from './assets/keyboardNav.png'
import Layout from './components/Layout.js'

<Head>
  <title>TL;DR Accessible Components</title>
</Head>

<Layout>

# TL;DR Accessible Components

</Layout>

---

<Layout>

# What is accessibility?
Websites, tools and technologies that are **designed** and **developed** so that people with disabilities can use them.

</Layout>

<Notes>

- What does it mean for something to be accessible?
- When things are accessible it benefits all people.
- But when we leave accessibility out of the work we do...

</Notes>

---

<Layout>

# Why is accessibility important?

</Layout>

<Notes>

- There are several reasons why accessibility should be a priority for us as engineers.
- The Legal and financial ones tend to take precedence when it comes to selling our stakeholders on why we need to prioritize accessibility on the roadmap.
- But I want to focus on one reason in particular, because it's the one that resonates most with me and I hope it will with you too.

</Notes>

---

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>

<Notes>

- As engineers we have a lot of power in shaping the impact we have on our users at scale.
- It's possible that we could have prevented someone from paying for their pills online.
- Because we used a div instead of an input element within a form.
- Or maybe a user doesn't know who wins the 2020 election because the page they're trying to access doesn't work with their screen reader.
- Which is one very serious consideration we have to make at The New York Times.


</Notes>

---

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>


<Notes>

- We shouldn't be the ones gatekeeping and limiting access to the web to a privileged few.
- Keeping the web universal and inclusive means we have to make our websites accessible.
- And to do that, we should start with the fundamentals.

</Notes>

---

<Layout>

# Components
Encapsulated, reusable, and custom elements.

</Layout>

<Notes>

- Components are one of the things that make React so powerful.
- They allow us to package up functionality and UI and utilize them in various parts of our codebase.
- They're the building blocks of our apps and websites.
- and if the blocks are reliable and well-built it stands to reason that our apps will be too.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- So if we designed and developed the building blocks to be accessible,
- Then maybe we can start making significant progress in building fully accessible websites.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- Unfortunately that's easier said than done.
- When I first started learning accessibility concepts the hardest things to figure out were the requirements for making components I'd built dozens of times and making them compatible with screen readers or interactive using only a keyboard.
- Naturally I thought that turning to the documentation would help clear up my confusion, but instead I was hit with this...

</Notes>

---

<Image src={wcagDocsGif} />

<Notes>

- A huge wall of text.
- Hundreds of links that go to even more documentation.
- And dozens of concepts that I didn't even know I didn't know.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- But that didn't get me off the hook, 
- I couldn't just brush accessibility under the rug.

</Notes>

---

<Layout>

# TL;DR
### Too Long; Didn't Read

</Layout>

<Notes>

- Instead I had to be more strategic about how I was approaching the documentation.

</Notes>

---

<Layout>

# TL;DR Accessible Components

</Layout>

<Notes>

- And that's what we're gonna be doing today during this talk.

</Notes>

---

<Layout>

# Yuraima Estevez
üë©‚Äçüíª Tech Lead @ New York Times

</Layout>

<Notes>

- I'm gonna share my too long; didn't read approach to building accessible components.
- It's the way that I tackle building accessible components by going off of the documentation
- and quickly identifying the critical requirements necessary.

</Notes>

---

<Layout>

# Three "Easy" Steps

  <ul>
    <Appear>
      <li>Semantic HTML</li>
      <li>ARIA attributes</li>
      <li>Keyboard navigation</li>
    </Appear>
  </ul>
  
</Layout>

<Notes>

- I've broken it down into 3 easy steps.
- Use semantic HTML whenever possible.
- Identify which ARIA attributes we need to add to those HTML elements.
- And manage keyboard navigation.

</Notes>

<!-- https://www.w3.org/WAI/standards-guidelines/wcag/ -->

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- You may notice I have "easy" in quotes.  That's because there's a caveat.
- Like any other skill in engineering it takes time to build up your understanding of accessibility.
- This isn't a silver bullet life hack and they're definitely not the ONLY things we need to consider.
- But by narrowing things down a bit I think it's easier and faster for us to ramp up and target exactly what we need to get up and running.

</Notes>

---

<Layout>

# Three "Easy" Steps
- **Semantic HTML**
- ARIA attributes
- Keyboard navigation

</Layout>


<Notes>

So let's Start with Semantic HTML  

</Notes>

---

<Layout>

# [Semantic HTML](https://www.w3.org/TR/wai-aria-1.1/#dfn-semantics)
Provides your content and components with meaning beyond their visual representation.

</Layout>

<Notes>

- One of the things that is so powerful about HTML is that it was fundamentally designed and built to be accessible.
- Because of this we can rely on semantic HTML elements to do a lot of the heavy lifting.
- This is critical for building websites that can be understood by assistive technologies.
- Assistive technologies are just software and hardware, they only understand the code you write.
- So if we want these technologies to properly identify and interact with our components we have to speak their language

</Notes>

---

<CodeSurfer>

```jsx
<div 
  onClick={eventHandler}>
  This is a "button"
</div>
```

</CodeSurfer>

<Notes>

  - RAISE HANDS: how many of us have done something like this?
  - Unfortunately this is just a div with a click handler.
  - Assistive technologies like screen readers will have NO idea that this element even exists.
  - And users that navigate the web using only a keyboard won't even be able to interact with this element because it only has a click handler attached to it.

</Notes>

---

<CodeSurfer>

```jsx
<button onClick={eventHandler}>
  Fully accessible
</button>
```

</CodeSurfer>

<Notes>

  - If we were to use the HTML button element we would get all of that for free.
  - Assistive technologies understand what this is and know how to interact with it.
  - And it's fully interactive using only a keyboard.

</Notes>

---

<CodeSurferColumns themes={[ github, vsDark ]}>

<Step>

```jsx
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx
const Button = ({ 
  buttonContent = 'I just work!', 
  activate
}) => (
  <button onClick={activate}>
    {buttonContent}
  </button>
)
```

</Step>

</CodeSurferColumns>

<Notes>

  - And a lot of times it's just easier for us to use the semantic HTML elements than it is to try and jam accessibility support into a div.
  - We'll go over what some of this does later but for now just look at all of the code it takes to make a div button accessible vs. a regular button element.

</Notes>

---

<Layout>

# Semantic HTML
There are over 100 elements available in HTML.

</Layout>

<Notes>

- So use the tools that you have available to you.

</Notes>

---

<CodeSurfer>

```jsx
<div className="navBar">
  <span
    className="link"
    onClick={goSomewhere}>
      Fake link 1
  </span>
  <span 
    className="link"
    onClick={goSomewhere}>
      Fake link 2
  </span>
  <span 
    className="link"
    onClick={goSomewhere}>
      Fake link 3
  </span>
</div>
```

</CodeSurfer>

<Notes>
  - If you want to build a nav bar...
</Notes>

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <ul>
    <li>
      <a href="#">Real link 1</a>
    </li>
    <li>
      <a href="#">Real link 2</a>
    </li>
    <li>
      <a href="#">Real link 3</a>
    </li>
  </ul>
</nav>
```

</CodeSurfer>

<Notes>
  - use the nav element, list items and anchors for your markup
</Notes>

---

<CodeSurfer>

```jsx
<div className="table">
  <div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
</div>
```

</CodeSurfer>

<Notes>
  - and instead of trying to reinvent the wheel by styling a table out of divs...
</Notes>

---

<CodeSurfer>

```jsx
<table>
  <tbody>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
    </tbody>
</table>
```

</CodeSurfer>

<Notes>
  
  - Use the table element and override the default styling
  - These elements were built with accessibility in mind and we should be leveraging them in the components we build whenever we can.

</Notes>

---

<Layout>

# Semantic HTML

</Layout>

<Notes>

- But of course... semantic HTML can't solve ALL of our accessibility problems

</Notes>

<!-- https://developer.mozilla.org/en-US/docs/Web/HTML/Element -->

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <dropdown>
    <a href="/about">About Page</a>
    <dropdownlist>
      <ul>
        <li>
          <a href="#">Real link 1</a>
        </li>
        <li>
          <a href="#">Real link 2</a>
        </li>
        <li>
          <a href="#">Real link 3</a>
        </li>
      </ul>
    </dropdownlist>
  </dropdown>
</nav>
```

</CodeSurfer>

<Notes>

- For example, it'd be GREAT if we could have something like this for when we want to build a nav bar that has a dropdown list in it.

</Notes>

---

<CodeSurfer>

```jsx 2,4,16,17
<nav className="navBar">
  <dropdown>
    <a href="/about">About Page</a>
    <dropdownlist>
      <ul>
        <li>
          <a href="#">Real link 1</a>
        </li>
        <li>
          <a href="#">Real link 2</a>
        </li>
        <li>
          <a href="#">Real link 3</a>
        </li>
      </ul>
    </dropdownlist>
  </dropdown>
</nav>
```

</CodeSurfer>

<Notes>

- Some kind of dropdown HTML elements based on common components like a dropdown list whose behavior would be managed by the browser would be amazing.
- And because it's a native HTML element, it would automatically be recognized by assistive technologies without any work on our part.

</Notes>

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <a href="/about">About Page</a>
  <ul className="dropDownList hidden">
    <li>
      <a href="#">Real link 1</a>
    </li>
    <li>
      <a href="#">Real link 2</a>
    </li>
    <li>
      <a href="#">Real link 3</a>
    </li>
  </ul>
</nav>
```

</CodeSurfer>

<Notes>

- But that's not the world we live in.
- Instead we make all the magic happen with CSS and JS to get this to work the way we think a dropdown menu should.
- But of course, this component isn't accessible as is because no screen reader or other assistive tech is going to be able to identify it as a menu bar with dropdown menu items.
- So what we need is a way to assign semantic meaning to our elements and components so that assistive technologies can work with them.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- **ARIA attributes**
- Keyboard navigation

</Layout>

<Notes>
- And that's where ARIA attributes come in handy.
</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)
**A**ccessible **R**ich **I**nternet **A**pplications

</Layout>

<Notes>

- stands for accessible rich internet applications
- set of HTML attributes that help define the semantics of an element or component.
- attributes that are Understood by assistive technologies

</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul>
  <Appear>
      <li>roles</li>
      <li>states</li>
      <li>properties</li>
  </Appear>
</ul>

</Layout>

<Notes>

- ARIA attributes are broken up into three categories
- roles define the type of element or component
- states and properties are supportive attributes that can be used with roles.

</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul>
  <li>roles</li>
  <li>states</li>
  <li>properties</li>
</ul>

</Layout>

<Notes>

- ARIA roles can be combined with states and properties and together they can be understood by assistive technologies so that they can announce them to the user.

</Notes>

---

<Image src={designPatternsIntro} />

<Notes>

- And a really helpful resource for figuring out which attributes do what is this design patterns and widgets section. 

</Notes>

---

<Image src={designPatternsIntro2} />

<Notes>

- It contains a list of common components that we're all familiar with.

</Notes>

---

<Image src={designPatternsIntro3} />

<Notes>

- And details what ARIA roles, states and properties are required and available to use for each component

</Notes>

---

<Image src={designPatternsMenuExample} />

<Notes>

- It also includes code samples in vanilla HTML, CSS and JS that we can use as our reference and translate to react.

</Notes>

---

<Layout>

# TL;DR ARIA [Button](https://www.w3.org/TR/wai-aria-practices/#wai-aria-roles-states-and-properties-3)

</Layout>

<Notes>

- So going off of the design pattern docs, let's break down the ARIA attributes our Button component needs

</Notes>

---

<CodeSurfer>

```jsx
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 17 title='add "button" ARIA role attribute'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- Here's our div button example from before.
- CODE TRANSITION
- We have to add in the button role so that assistive tech can identify this plain div as a button.
- Let's say we have a screen reader, it will announce that this element is a button and a user will know that they can interact with it.

</Notes>

---

<CodeSurfer>

```jsx 17 title='add "button" ARIA role attribute'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 3,18 title='add "aria-labelledby" or "aria-label" property'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- We also want to pass in a value for an accessible button label using the aria-label or aria-labelledby properties.
- Usually the screen reader will read the content inside of the button by default...
- But if we needed to override that value we could explicitly pass in what should be announced for this button.
- This is handy if we have button that have non-text content like images or icons.

</Notes>

---

<CodeSurfer>

```jsx 3,18 title='add "aria-labelledby" or "aria-label" property'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 4,19 title='add "aria-disabled" state if button is inactive'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- And lastly we have to make sure we signal to assistive tech when a button is inactive.
- We can do that by adding the aria-disabled state attribute and set it to true or false based on the button's inactive state.
- That's about it for ARIA attributes for our simple button

</Notes>

---

<Layout>

# TL;DR ARIA [Dialog](https://www.w3.org/TR/wai-aria-practices/#dialog_roles_states_props)(Modal)

</Layout>

<Notes>

- Here's another component that's listed in the design patterns documentation.

</Notes>

---

<CodeSurfer>

```jsx title='ARIA Modal'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 11 title='add "dialog" role to modal container'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- Let's take a look at the ARIA attributes we need to make our modal accessible.
- CODE TRANSITION
- our modal container needs the ARIA role attribute set to "dialog"

</Notes>

---

<CodeSurfer>

```jsx 11 title='add "dialog" role to modal container'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 12 title='set "aria-modal" state when active'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we need our assistive tech to know when our modal is open and active, we do that with the aria-modal state attribute.
- set that to true based on some component state.

</Notes>

---

<CodeSurfer>


```jsx 12 title='set "aria-modal" state when active'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 2,13,14 title='"aria-label" or "aria-labelledby"'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we also have to provide an accessible label, so I'm using aria-labelledby property for that
- I set the value of it to the ID of an element that contains the modal title, that's my h2 here.
- And that's about it for a VERY simple accessible modal.

</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

</Layout>

<Notes>

- Now you probably noticed a very important characteristic about ARIA attribute through all of that.
- ARIA attributes function only as a way to communicate with assistive technologies like screen readers.
- What they DON'T do, is help with keyboard interactions.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- **Keyboard navigation**

</Layout>

<Notes>

- That's our third and last easy step.
- all of our components have to support keyboard only navigation.
- and that's because not everyone uses a mouse as their primary device for navigation.

</Notes>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
How can a user interact with our components using only a keyboard?

</Layout>

<Notes>

- Unless we're relying solely on sematic HTML elements, we're entirely responsible for managing keyboard navigation.
- So we need to consider how a user would be able to interact with our components using only a keyboard.

</Notes>

---

<Image src={keyboardNav} />

<Notes>

- And this is another way the W3C docs makes it fairly easy to uncover these requirements.
- They have an entire section that explains how a component can be interacted with using only a keyboard.
- and this includes a list of which keys do what within the component.

</Notes>

---

<Layout>

# TL;DR [Button](https://www.w3.org/TR/wai-aria-practices/#keyboard-interaction-3) Keyboard Navigation

</Layout>

<Notes>

- Let's work through what the keyboard requirements are for one of our components

</Notes>

---

<CodeSurfer>

```jsx
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 17 title='add "button" ARIA role attribute'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- Here's our trusty div button that we've grown to love.
- CODE TRANSITION
- We have to add in the button role so that assistive tech can identify this plain div as a button.
- Let's say we have a screen reader, it will announce that this element is a button and a user will know that they can interact with it.

</Notes>

---

<Layout>

# Common Conventions
- `tab` and `shift+tab` move focus from one component to another
- arrows keys move focus from one interactive element to another _within_ a component 
- `Enter` and `Space` will activate an interactive element.

</Layout>

<!-- A primary keyboard navigation convention common across all platforms is that the tab and shift+tab keys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements. The path that the focus follows when pressing the tab key is known as the tab sequence or tab ring. -->

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Make sure your user knows where their keyboard focus is
<!-- When operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed. The following factors affect to what extent a web page affords users these capabilities. -->

</Layout>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
- Make sure the focus indicator is always visible.

</Layout>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
- Managing focus so that it persists between interaction events.

</Layout>

<Notes>

- If I open a modal by interacting with this button
- My focus is moved inside of the modal.  When I close the modal, what happens to my focus?
- It shouldn't just disappear or go back to the top of the page
- These should be as natural and predictable as possible.

</Notes>

---

<Layout>

# TL;DR
- Use common conventions for keyboard navigation.
- Keyboard focus indicator should always be visible.
- Focus should persist between interaction events.

</Layout>

---

<Layout>

# Thank You!

</Layout>


