import { Head, Notes, Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { vsDark, github, dracula } from "@code-surfer/themes";
import customTheme from './theme'

export const theme = customTheme;
import './styles.css'

import wcagDocsGif from './assets/wcagDocs.gif'
import designPatternsImage from './assets/designPatterns.png'
import alertDesignPattern from './assets/alertDesignPattern.png'
import alertExample1 from './assets/alertExample1.png'
import alertExample2 from './assets/alertExample2.png'
import alertExample3 from './assets/alertExample3.png'
import designPatternsIntro from './assets/designPatternsIntro.png'
import designPatternsIntro2 from './assets/designPatternsIntro2.png'
import designPatternsIntro3 from './assets/designPatternsIntro3.png'
import designPatternsMenuExample from './assets/designPatternsMenuExample.png'
import keyboardNav from './assets/keyboardNav.png'
import buttonAriaDocs from './assets/buttonAriaDocs.png'
import buttonAriaRole from './assets/buttonAriaRole.png'
import buttonAriaLabel from './assets/buttonAriaLabel.png'
import buttonAriaDisabled from './assets/buttonAriaDisabled.png'
import buttonActivate from './assets/buttonActivate.png'
import keyboardFocus1 from './assets/keyboardFocus1.gif'
import keyboardFocus2 from './assets/keyboardFocus2.gif'
import Layout from './components/Layout.js'
import FullImage from './components/FullImage.js'
import List from './components/List.js'

<Head>
  <title>TL;DR Accessible Components</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400&display=swap" rel="stylesheet" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300&display=swap');
  </style>
</Head>

<Layout showWebsite={true}>

# 👋 Hello!

</Layout>

---

<Layout showWebsite={true}>

# Yuraima Estevez
<p class="accentText">Engineering Manager @ The New York Times</p>

</Layout>

<Notes>



</Notes>

---

<!-- intro -->

<Layout>

# What is accessibility?
Websites, tools and technologies that are **designed** and **developed** so that people with disabilities can use them.

</Layout>

---

<!-- intro -->

<Layout>

# Why is accessibility important?

</Layout>

<Notes>

- There are several reasons why accessibility should be a priority for us as engineers.
- Of course there are monetary and legal reasons for why we should care about accessibility in our day-to-day
- But I want to focus on one reason in particular, because it's the one that resonates most with me and I hope it will with you too.

</Notes>

---

<!-- intro and morality -->

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>

<Notes>

- As engineers we have a lot of power in shaping the impact we have on our users at scale.
- All of us work at very different companies and across a multitude of industries.
- that means we're building products for many different users, including those with disabilities.
- when we don't build our apps and websites accessibly, we make it hard our impossible for some people to use them.
- seemingly small mistake... posting meme without alternative meaning screen reader users won't be able to laugh along with us.
- OR a detrimental mistake... building an inaccessible checkout flow that makes it impossible for some users to buy groceries online.
- In a time like this we can all imagine what that must feel like, what effect that can have on a person's life.

</Notes>

---

<!-- intro and morality cont'd -->

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>


<Notes>

- We shouldn't be the ones gatekeeping and limiting access to the web.
- But when we aren't mindful of the code we're writing and the users that are impacted by it, that can sometimes be the result.
- Keeping the web universal and inclusive means we have to make our websites accessible.
- And to do that, we should start at the foundation.

</Notes>

---

<!-- discuss components -->

<Layout>

# Components
Encapsulated, reusable, and custom elements.

</Layout>

<Notes>

- Components are one of the things that make React so powerful.
- They allow us to package up functionality and UI and utilize them in various parts of our codebase.
- They're the building blocks of our apps and websites.
- and if the blocks are reliable and well-built it stands to reason that our apps will be too.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- So if we designed and developed the building blocks to be accessible,
- Then maybe we can start making significant progress in building fully accessible websites that work for everyone.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- Unfortunately that's easier said than done.
- When I first started learning accessibility concepts one of the hardest things to figure out was how I could take components I'd built dozens of times and uncover the requirements for making them accessible
- Naturally, I thought that turning to the documentation would help clear up my confusion, but instead I was hit with this...

</Notes>

---

<!-- Gif of WCAG huge wall of text -->

<FullImage src={wcagDocsGif} />

<Notes>

- A huge wall of text.
- Hundreds of links that go to even more documentation.
- And dozens of concepts that I didn't even know I didn't know.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- But that didn't get me off the hook, 
- I couldn't just brush accessibility under the rug.

</Notes>

---

<Layout>

# TL;DR
### Too Long; Didn't Read

</Layout>

<Notes>

- Instead I had to be more strategic about how I was approaching the documentation.

</Notes>

---

<Layout>

# TL;DR Accessible Components

</Layout>

<Notes>

- And that's what we're gonna be doing today during this talk.
- too long; didn't read approach to building accessible components.
- and quickly identifying the critical requirements necessary by going off of the documentation

</Notes>

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

  <List>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
  </List>
  
</Layout>

<Notes>

- I've broken it down into 3 easy parts.
- NEXT: Use semantic HTML whenever possible to do the heavy lifting
- NEXT: Identify which ARIA attributes we need to add to those elements when semantic HTML isn't exactly enough.
- NEXT: And manage keyboard navigation for users that don't interact with the web using a mouse.

</Notes>

<!-- https://www.w3.org/WAI/standards-guidelines/wcag/ -->

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

<List appear={false}>
  <li>Semantic HTML</li>
  <li>ARIA attributes</li>
  <li>Keyboard navigation</li>
</List>

</Layout>

<Notes>

- "easy" in quotes.  there's a caveat.
- it takes time to build up your understanding of accessibility.
- NOT silver bullet life hack and not the ONLY things we need to consider.
- narrowing things down makes it easier and faster for us to ramp up and target exactly what we need to get up and running.

</Notes>

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

<List appear={false}>
  <li style={{ fontWeight: 'bold'}}>Semantic HTML</li>
  <li>ARIA attributes</li>
  <li>Keyboard navigation</li>
</List>

</Layout>


<Notes>

So let's Start with Semantic HTML  

</Notes>

---

<!-- Start semantic HTML topic -->

<Layout>

# [Semantic HTML](https://www.w3.org/TR/wai-aria-1.1/#dfn-semantics)
Provides your content and components with meaning beyond their visual representation.

</Layout>

<Notes>

- HTML was fundamentally designed and built to be accessible.
- we can rely on semantic HTML elements to do a lot of the heavy lifting when building components.
- Assistive technologies are just software and hardware, they only understand the code you write.
- Don't understand our good intentions or context on the page.
- We have to speak their language, semantic HTML is part of that language.

</Notes>

---

<!-- inaccessible button div component -->

<CodeSurfer theme={github}>

```jsx file=./code/semantic-html-0.0.0.js
```

</CodeSurfer>

<Notes>

  - We're all guilty of this.  Build a button, use a div.  Styling is easier.
  - Divs have no semantic meaning, Assistive technologies will have NO idea that this element even exists.
  - Keyboard only users won't be able to interact, because divs are not interactive by default.

</Notes>

---

<!-- accesible button component with button html element -->

<CodeSurfer theme={github}>

```jsx file=./code/semantic-html-0.0.1.js
```

</CodeSurfer>

<Notes>

  - Luckily there's an HTML element that represents a button.
  - Assistive technologies understand what this is and know how to interact with it.
  - Keyboard support out of the box.

</Notes>

---

<!-- lots of html elements, all semantic -->

<Layout>

# Semantic HTML
There are over 100 elements available in HTML.

</Layout>

<Notes>

- over 100 elements.  almost all of them have some semantic meaning we can leverage.
- div and span are the only elements with no semantic meaning.
- So use the tools that you have available to you.
- It's easier to rely on semantic HTML than try to build in accessibility support after the fact.

</Notes>

---

<!-- side by side button components -->

<CodeSurferColumns themes={[ vsDark, github ]}>

<Step>

```jsx file=./code/semantic-html-0.0.2.js
```

```jsx file=./code/semantic-html-0.0.3.js
```

</Step>

</CodeSurferColumns>

<Notes>

  - to illustrate, let's look at two button components.
  - left, a div button.  right, html button.
  - so many more lines of code on the left to make our div button fully accesible
  - on the right, html button just works accessibly because design and developed to.

</Notes>

<!-- TODO: You should add some kind of transition/wrap up here to semantic HTML -->

---

<!-- semantic html wrap up -->

<Layout>

# Semantic HTML

</Layout>

<Notes>

- These elements were built with accessibility in mind. 
- leverage them in the components we build whenever we can to make our lives easier
- ...
- But of course... semantic HTML can't solve ALL of our accessibility problems

</Notes>

<!-- https://developer.mozilla.org/en-US/docs/Web/HTML/Element -->

---

<!-- fake semantic html nav bar -->

<CodeSurfer theme={github}>

```jsx file=./code/semantic-html-0.0.8.js
```

```jsx 2,4,16,17 file=./code/semantic-html-0.0.8.js
```

</CodeSurfer>

<Notes>

- over 100 semantic elements, but that isn't always enough when building out more complext components.
- Something like this doesn't exist in HTML.  Nav bar with dropdown menu items.
- NEXT: wish list elements, dropdown element whose semantic meaning and behavior is managed entirely by the browser.
- native HTML element so it would be accessible out of the box.

</Notes>

---

<!-- actual html nav bar -->

<CodeSurfer theme={github}>

```jsx file=./code/semantic-html-0.0.9.js
```

</CodeSurfer>

<Notes>

- But that's not the world we live in.
- Instead we make all the magic happen with CSS and JS to behave like a dropdown menu.
- isn't accessible as is because no assistive tech can identify it as a menu bar with dropdown menu items.
- need a way to assign additional semantic meaning to our more complex components so that assistive technologies can work with them.

</Notes>

---

<!-- moving on to aria attributes -->

<Layout>

# Three "Easy" Parts

<List appear={false}>
    <li>Semantic HTML</li>
    <li style={{ fontWeight: 'bold'}}>ARIA attributes</li>
    <li>Keyboard navigation</li>
</List>

</Layout>

<Notes>
- And that's where ARIA attributes come in handy.
</Notes>

---

<!-- what is aria 1 -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)
**A**ccessible **R**ich **I**nternet **A**pplications

</Layout>

<Notes>

- stands for accessible rich internet applications
- set of HTML attributes that help define/enhance the semantics of an element or component.
- So that they can be understood by assistive technologies
- useful for dynamic and more complex behavior

</Notes>

---

<!-- what is aria 2 -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<List>
  <li>roles</li>
  <li>states</li>
  <li>properties</li>
</List>

</Layout>

<Notes>

- ARIA attributes are broken up into three categories
- NEXT: roles define the type of element or component
- NEXT: states
- NEXT: properties are supportive attributes to provide more details

</Notes>

---

<!-- aria - different kinds of attributes -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<List appear={false}>
  <li>roles</li>
  <li>states</li>
  <li>properties</li>
</List>

</Layout>

<Notes>

- roles combined with states and properties
- help properly communicate to assistive technologies what our component is, how it behaves, interaction
- Lots of attributes to use, sometimes hard to know which combination of attributes to use when.

</Notes>

---

<!-- WAI-ARIA design patterns -->

<FullImage src={designPatternsIntro} />

<Notes>

- But this is where we can turn to the docs to help guide us
- helpful resource for figuring out which attributes to use in our components is WAI-ARIA authoring practices.

</Notes>

---

<!-- what is wai-aria -->

# WAI-ARIA
**W**eb **A**ccessiblity **I**nitiative ARIA

<Notes>

- stands for...
- best practices and guidelines for how to use aria attributes to build out dynamic and complex user experiences in an accessible way.

</Notes>

---

<!-- WCAG design patterns 2 -->

<FullImage src={designPatternsIntro2} />

<Notes>

- It contains a list of common components that we're all familiar with.
- alerts, checkboxes, modals, handful of others....

</Notes>

---

<!-- WCAG design patterns 3 -->

<FullImage src={designPatternsIntro3} />

<Notes>

- And details what ARIA roles, states and properties are required and available to use for each component
- to make them work with assistive technologies

</Notes>

---

<!-- WCAG design patterns menu example-->

<FullImage src={designPatternsMenuExample} />

<Notes>

- It also includes code samples in HTML, CSS and vanilla JS
- I like to refer to those when I'm building out my React components to get a sense of the component logic
- translate that to react.

</Notes>

---

<!-- aria warning -->

<Layout>

# 🚨 ARIA 🚨
The best ARIA is no ARIA at all.

</Layout>

<Notes>

- before digging into Aria.
- quick warning, a general rule of thumb is...
- The best aria is no aria at all.
- If there are HTML elements that support what you're trying to do, use those instead of using ARIA.
- If you don't know if your ARIA setup is correct, better not to use it.
- ARIA is incredibly powerful because it overrides all the semantic meaning for the elements they're applied to. 
- if they are used incorrectly, it could render your components completely useless to assistive tech, and create a terrible user experience.
- when used correctly they add the additional accessibility support necessary for our users to be able to interact with dynamic and complex components.

</Notes>

---

<!-- aria button component -->

<Layout>

# TL;DR ARIA [Button](https://www.w3.org/TR/wai-aria-practices/#wai-aria-roles-states-and-properties-3)

</Layout>

<Notes>

- now that that's out of the way...
- Let's see what we can do with ARIA by going back to our button component.
- WAI-ARIA design patterns includes a writeup for how to build an accessible button from scratch.
- I said we should always try to use semantic html, but sometimes we do have to build our own buttons.
- when we do, make sure they're accessible

</Notes>

---

<!-- button docs step through -->

<FullImage src={buttonAriaDocs} />

<Notes>

- the wai-aria design patterns doc includes a write up of roles states properties for making an accessible button.
- let's step through and work through what that looks like

</Notes>

---

<!-- button docs step through -->

<FullImage src={buttonAriaRole} />

<Notes>

- the first thing listed... our component needs an aria role attribute set to "button"
- Add so assistive tech can identify this plain div as a button.

</Notes>

---

<!-- aria button code 1 -->

<CodeSurfer theme={github}>

```jsx file=./code/aria-0.0.0.js
```

```jsx 17 file=./code/aria-0.0.0.js title='add "button" ARIA role attribute'
```

</CodeSurfer>

<Notes>

- Here's our div button example from before.
- CODE TRANSITION
- add in our aria role attribute and set it to "button"
- now a screen reader will announce that this element is a button and a user will know that they can interact with it.

</Notes>

---

<!-- button docs step through -->

<FullImage src={buttonAriaLabel} />

<Notes>

- we also need to make sure that our button has an accessible label.

</Notes>

---

<!-- button docs step through -->

<Layout>

  <button>Submit</button>
  <p>Screen Reader: Submit, button</p>

</Layout>

<Notes>

- according to the docs...
- by default, the accessible name of a button derived by any text content inside of the button
- here a screen reader would announce, "button, Submit" because the word submit is inside of our button.

</Notes>

---

<!-- button docs step through -->

<Layout>

  <button>👋</button>
  <p>Screen Reader: waving hand, button</p>

</Layout>

<Notes>

- but sometimes the content inside of our button isn't screen reader friendly
- here i have an emoji inside of a button because who doesn't love a good emoji
- in this case a screen reader would announce this as: "waving hand, button"

</Notes>

---

<!-- button docs step through -->

<Layout>

  <button>👋</button>
  <p>Screen Reader: waving hand, button</p>
  <p>User: 😕 🤔</p>

</Layout>

<Notes>

- that gives the user no indication of what this button does whatsoever.

</Notes>

---

<!-- button docs step through -->

<Layout>

  <button>👋</button>
  <p>Screen Reader: Submit form, button</p>
  <p>User: 👍 😌</p>

</Layout>

<Notes>

- In this case, we want a way to override what the screen reader announces
- we can do this by setting an accessible label in our button.

</Notes>

---

<!-- aria button code 2 -->

<CodeSurfer theme={github}>

```jsx file=./code/aria-0.0.0.js title='add "button" ARIA role attribute'
```

```jsx 3,18 file=./code/aria-0.0.0.js title='add "aria-labelledby" or "aria-label" property'
```

```jsx 18 file=./code/aria-0.0.0.js title='add "aria-labelledby" or "aria-label" property'
```

</CodeSurfer>

<!-- TODO: add in screenshots of specific doc areas and example of non-text button content -->

<Notes>

- CODE TRANSITION
- I have an accessibleLabel prop that i can pass into my component
- NEXT: if the accessibleLabel prop exists, then i want to render an aria-label attribute on my button.
- notice that I'm not just setting it to an empty string

</Notes>

---


<!-- button docs step through -->

<Layout>

  <code>aria-label=""</code>
  <p>Screen Reader: button</p>
  <p>User: 😕 🤔</p>

</Layout>

<Notes>

- remember, aria attributes take precedence on the elements they're applied to.
- even if this button has text content in it, if aria-label is present then that's what the AT will announce
- if aria-label is present and empty, screen reader will just announce as button
- again, giving user no indication of what this button is or does.
- use aria attributes responsibly.

</Notes>

---

<!-- button docs step through -->

<FullImage src={buttonAriaDisabled} />

<Notes>

- last, signal to assistive tech when a button is inactive.
- set the aria-disabled state attribute and set that to true or false.

</Notes>

---

<!-- aria button code 3 -->

<CodeSurfer theme={github}>

```jsx 4,19 file=./code/aria-0.0.0.js title='add "aria-disabled" state if button is inactive'
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- here, isDisabled prop that gets passed in
- true or false based on the button's inactive state 
- value set to the aria-disabled attribute.
- now a user can know when button is active/inactive.
- ...
- There are a few other points in docs around additional ARIA attributes we can add to our button.
- This is all we need for our simple button, let's recap

</Notes>

<!-- TODO: needs a better transition/wrap up to keyboard nav -->

---

<!-- aria wrap up -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)
HTML attributes that help define/enhance the semantics of our components to make them accessible.

</Layout>

<Notes>

- define/enhance semantics of complex and dynamic components to make accessible.

</Notes>

---

<!-- roles wrap up -->

<Layout>

# [ARIA `role`]()
<code>
  <table>
    <tr>
      <td>button</td>
      <td>radio</td>
      <td>alert</td>
    </tr>
    <tr>
      <td>tab</td>
      <td>menu</td>
      <td>tooltip</td>
    </tr>
    <tr>
      <td>dialog</td>
      <td>timer</td>
      <td>checkbox</td>
    </tr>
  </table>
</code>


</Layout>

<Notes>

- aria roles identify the kind of component to assistive technologies

</Notes>

---

<!-- states and properties wrap up -->

<Layout>

# [ARIA states and properties]()
<code>
  <table>
    <tr>
      <td>aria-checked</td>
      <td>aria-live</td>
    </tr>
    <tr>
      <td>aria-required</td>
      <td>aria-disabled</td>
    </tr>
    <tr>
      <td>aria-busy</td>
      <td>aria-controls</td>
    </tr>
    <tr>
      <td>aria-selected</td>
      <td>aria-describedby</td>
    </tr>
  </table>
</code>


</Layout>

<Notes>

- states properties used by their supported roles to help describe the component throughout its life-cycle.
- There are many different roles states and properties we can use, and the wai-aria documentation helps decipher the combination needed to make our components accessible.

</Notes>

---

<!-- aria wrap up -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

</Layout>

<Notes>

- remember, the best aria is no aria at all.  Use semantic html elements where appropriate.  
- If we're not sure we have the right combination of aria attributes, best to leave them out entirely.
- ...
- Now that we know how to make assistive tech understand our components...

</Notes>

---

<!-- keyboard nav intro -->

<Layout>

# Three "Easy" Parts

<List appear={false}>
  <li>Semantic HTML</li>
  <li>ARIA attributes</li>
  <li  style={{ fontWeight: 'bold'}}>Keyboard navigation</li>
</List>

</Layout>

<Notes>

- talk about how our users can INTERACT with our components accessibly.
- Not everyone uses a mouse as their primary device for navigation.
- some use the keyboard or some assistive tech that maps more or less to keyboard interactions.
- that means all of our components have to support keyboard only navigation.

</Notes>

---

<!-- keyboard nav intro 2 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
How can a user interact with our components using only a keyboard?

</Layout>

<Notes>

- So we need to consider how a user would be able to interact with our components using only a keyboard.
- Unless we're relying solely on semantic HTML elements, we're entirely responsible for managing keyboard navigation.

</Notes>

---

<!-- keyboard nav intro -->

<FullImage src={keyboardNav} />

<Notes>

- Different components require different keyboard support
- wai-aria documentation clearly spells out expected support for many different components
- They have an entire section that explains how a component can be interacted with using only a keyboard.

</Notes>

---

<!-- button keyboard nav -->

<Layout>

# TL;DR [Button](https://www.w3.org/TR/wai-aria-practices/#keyboard-interaction-3) Keyboard Navigation

</Layout>

<Notes>

- Back to our div button component
- work through the docs to figure out how we can support keyboard navigation

</Notes>

---

<!-- button keyboard nav code -->

<CodeSurfer theme={github}>

```jsx file=./code/aria-0.0.0.js
```

```jsx 16 file=./code/aria-0.0.0.js title='add "tabindex" attribute'
```

</CodeSurfer>

<Notes>

- our div element is not interactive by default, so the first thing to do is make sure we can tab to it and give it keyboard focus.
- NEXT
- We can do that by adding the tabindex attribute to our button and setting it to "0"
- this will allow our div to gain keyboard focus when our user reaches in the natural taborder

</Notes>

---

<FullImage src={buttonActivate} />

<Notes>

- According to the docs...
- when button has focus we can interact with it using the space and enter keys
- these keys will activate our button

</Notes>

---

<!-- button keyboard nav code 3 -->

<CodeSurfer theme={github}>

```jsx file=./code/aria-0.0.0.js title='add "tabindex" attribute'
```

```jsx 5 file=./code/aria-0.0.0.js
```

```jsx 20 file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- NEXT
- We're passing an activate function to our button 
- NEXT: this gets called when our onClick event fires.
- But we also need a way to trigger our activate function when the space or enter key is pressed

</Notes>

---

<!-- button keyboard nav code 4 -->

<CodeSurfer theme={github}>

```jsx 20 file=./code/aria-0.0.0.js
```

```jsx 21 file=./code/aria-0.0.0.js title="add a keyboard event listener"
```

```jsx 8:12 file=./code/aria-0.0.0.js title='Listen for "Enter" and "Space"'
```

```jsx 10 file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- add a key listener to our button, run a function when a key is pressed
- i'll use the onKeyPress event listener.
- CODE TRANSITION
- onKeyPress event handler needs to check if space or enter key pressed when it's called.
- If space or enter was pressed...
- NEXT: we'll go ahead and run that same activate function that we passed to the onClick event.

</Notes>

---

<!-- button keyboard nav code 5 -->

<CodeSurfer theme={github}>

```jsx 10 file=./code/aria-0.0.0.js
```

```jsx file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- And now we have a very simple div button that is keyboard accessible.
- Made sure our button could be interacted with, add to taborder using tabindex
- assigned an onKeyPress event handler to listen to the space and enter key and activate button

</Notes>

---

<!-- button keyboard nav code 6 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)

</Layout>

<Notes>

- this was a very simple example of keyboard nav for a single button.
- There are a couple other considerations we should make when building up our component keyboard navigation

</Notes>

---

<!-- button keyboard nav code 7 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Make sure your user knows where their keyboard focus is.

</Layout>

<Notes>

- Make sure your user knows where their keyboard focus is.

</Notes>

---

<!-- keyboard focus example -->

<FullImage src={keyboardFocus1} />

<Notes>

- That means we should make sure we always have some visible indicator for which elements currently have focus.
- At the very least that means that we shouldn't eliminate or change the focus outline on active elements.
- there will always be someone that asks if you can get rid of it.
- Also, need a predictable tab order so that our users can more or less know where their focus will go when they tab to the next or previous element.

</Notes>

---

<!-- manage focus -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Manage focus so that it persists between interaction events.

</Layout>

<Notes>

- Manage focus so that it persists between interaction events.

</Notes>

---

<!-- modal example for focus -->

<FullImage src={keyboardFocus2} />

<Notes>

- we've all built modals, very few of us have built them accessibly.
- How would you build a modal in react? render/unmount based on component state.
- be mindful: what happens to focus when component gets rendered?
- what happens to focus when my component unmounts?
- in this example: activate modal by pressing button using the keyboard.
- when my modal opens, keyboard focus switches to the interactive elements inside of the modal.
- when modal closes, keyboard focus has to return to the original activator button.
- focus Has to be persistent and predictable throughout component life-cycle, that's something we have to build ourselves.

</Notes>

---

<!-- keyboard recap -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)

</Layout>

<Notes>

- to recap.
- all of our components need to have keyboard support.
- map out how a user would navigate your components using only a keyboard.
- make sure non-interactive elements can gain keyboard focus using the tabindex attribute.
- the wai-aria docs figure out which interactions you have to build in order for your component to respond to key presses.
- Always ensure our user know where their keyboard focus is...
- and that it persists throughout your component life-cycle.

</Notes>

---

<!-- final recap -->

<Layout>

# Three "Easy" Parts

  <List>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
  </List>
  
</Layout>

<Notes>

- quick recap
- We have three things that we should keep in mind when we're building our components.
- Use semantic HTML whenever possible, these will do a lot of the hard work for us.
- Identify which ARIA attributes we need to add to those HTML elements for more complex/dynamic components.
- But no aria is the best aria. Use responsibly, or not at all.
- And manage keyboard navigation. Some users can't use mouse, rely on keyboards.  Keyboard navigation must be supported.
- Uncovered the places in the wai-aria documentation that help guide our component development when it comes to these three topics.

</Notes>

---

<!-- final recap 2 -->

<Layout>

# Three "Easy" Parts

  <List appear={false}>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
  </List>
  
</Layout>

<Notes>

- And I want to reiterate that these are just techniques to hopefully make building accessible components easier.
- They are not the only things we have to consider.
- There are a lot of other factors to weigh..
- things like...

</Notes>

---

<!-- other things to consider -->

<Layout>

# Accessible design
  
</Layout>

<Notes>

- Whether or not our visual design is accessible.
- Do we meet the requirements for color contrast.
- and are we making sure that we consider folks with different visual impairments during our design phase.

</Notes>

---

<!-- other things to consider 2 -->

<Layout>

# Accessible SPAs
  
</Layout>

<Notes>

- what if we have a single page application?
- how does navigation between pages using something like react router affect screen readers and keyboard navigation?

</Notes>

---

<Layout>

# Testing accessibility
  
</Layout>

<Notes>

- Are we writing unit, integration and e2e tests that check to make sure we aren't breaking accessibility support with each change to our components?
- shameless plug... my talk, check it out
- And most importantly...

</Notes>

---

<!-- other things to consider 3 -->

<Layout>

# The user
  
</Layout>

<Notes>

- Are we considering our users?
- Sometimes as engineers it's hard to remember that we are not our users, and what may work for us or what we think makes the most sense to us, may not actually be what the user needs.
- Hopefully the topics we covered today will give you a better understanding of what your users need.
- Now that you have the tools and knowledge for building accessible components...
- Can put it all together to build accessible websites and apps..
- and ultimately help make the web an open and inclusive place for everyone.

</Notes>

---

<Layout>

# Thank You ❤️

</Layout>

<Notes>

- find slides with the resources on my website, and i'll tweet out the link in a few minutes.
- thank you so much for tuning into this talk
- and thank you to the conference organizers for putting together an amazing event.
- come hang out in the discord channel to ask questions or chat with each other
- stick around for the incredible day we have ahead of us!

</Notes>


