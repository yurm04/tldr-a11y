import { Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { vsDark, github, dracula } from "@code-surfer/themes";
import customTheme from './theme'

export const theme = customTheme;
import './styles.css'

import wcagDocsGif from './assets/wcagDocs.gif'
import designPatternsImage from './assets/designPatterns.png'
import alertDesignPattern from './assets/alertDesignPattern.png'
import alertExample1 from './assets/alertExample1.png'
import alertExample2 from './assets/alertExample2.png'
import alertExample3 from './assets/alertExample3.png'
import designPatternsIntro from './assets/designPatternsIntro.png'
import designPatternsIntro2 from './assets/designPatternsIntro2.png'
import designPatternsIntro3 from './assets/designPatternsIntro3.png'
import designPatternsMenuExample from './assets/designPatternsMenuExample.png'
import Layout from './components/Layout.js'

<Head>
  <title>TL;DR Accessible Components</title>
</Head>

<Layout>

# TL;DR Accessible Components

</Layout>

---

<Layout>

# What is accessibility?
Websites, tools and technologies that are **designed** and **developed** so that people with disabilities can use them.

</Layout>

<Notes>

- What does it mean for something to be accessible?
- When things are accessible it benefits all people.
- But when we leave accessibility out of the work we do...

</Notes>

---

<Layout>

# Why is accessibility important?

</Layout>

<Notes>

- There are several reasons why accessibility should be a priority for us as engineers.
- The Legal and financial ones tend to take precedence when it comes to selling our stakeholders on why we need to prioritize accessibility on the roadmap.
- But I want to focus on one reason in particular, because it's the one that resonates most with me and I hope it will with you too.

</Notes>

---

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>

<Notes>

- As engineers we have a lot of power in shaping the impact we have on our users at scale.
- It's possible that we could have prevented someone from paying for their pills online.
- Because we used a div instead of an input element within a form.
- Or maybe a user doesn't know who wins the 2020 election because the page they're trying to access doesn't work with their screen reader.
- Which is one very serious consideration we have to make at The New York Times.


</Notes>

---

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>


<Notes>

- We shouldn't be the ones gatekeeping and limiting access to the web to a privileged few.
- Keeping the web universal and inclusive means we have to make our websites accessible.
- And to do that, we should start with the fundamentals.

</Notes>

---

<Layout>

# Components
Encapsulated, reusable, and custom elements.

</Layout>

<Notes>

- Components are one of the things that make React so powerful.
- They allow us to package up functionality and UI and utilize them in various parts of our codebase.
- They're the building blocks of our apps and websites.
- and if the blocks are reliable and well-built it stands to reason that our apps will be too.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- So if we designed and developed the building blocks to be accessible,
- Then maybe we can start making significant progress in building fully accessible websites.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- Unfortunately that's easier said than done.
- When I first started learning accessibility concepts the hardest things to figure out were the requirements for making components I'd built dozens of times and making them compatible with screen readers or interactive using only a keyboard.
- Naturally I thought that turning to the documentation would help clear up my confusion, but instead I was hit with this...

</Notes>

---

<Image src={wcagDocsGif} />

<Notes>

- A huge wall of text.
- Hundreds of links that go to even more documentation.
- And dozens of concepts that I didn't even know I didn't know.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- But that didn't get me off the hook, 
- I couldn't just brush accessibility under the rug.

</Notes>

---

<Layout>

# TL;DR
### Too Long; Didn't Read

</Layout>

<Notes>

- Instead I had to be more strategic about how I was approaching the documentation.

</Notes>

---

<Layout>

# TL;DR Accessible Components

</Layout>

<Notes>

- And that's what we're gonna be doing today during this talk.

</Notes>

---

<Layout>

# Yuraima Estevez
üë©‚Äçüíª Tech Lead @ New York Times

</Layout>

<Notes>

- I'm gonna share my too long; didn't read approach to building accessible components.
- It's the way that I tackle building accessible components by going off of the documentation
- and quickly identifying the critical requirements necessary.

</Notes>

---

<Layout>

# Three "Easy" Steps

  <ul>
    <Appear>
      <li>Semantic HTML</li>
      <li>ARIA attributes</li>
      <li>Keyboard navigation</li>
    </Appear>
  </ul>
  
</Layout>

<Notes>

- I've broken it down into 3 easy steps.
- Use semantic HTML whenever possible.
- Identify which ARIA attributes we need to add to those HTML elements.
- And manage keyboard navigation.

</Notes>

<!-- https://www.w3.org/WAI/standards-guidelines/wcag/ -->

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- You may notice I have "easy" in quotes.  That's because there's a caveat.
- Like any other skill in engineering it takes time to build up your understanding of accessibility.
- This isn't a silver bullet life hack and they're definitely not the ONLY things we need to consider.
- But by narrowing things down a bit I think it's easier and faster for us to ramp up and target exactly what we need to get up and running.

</Notes>

---

<Layout>

# Three "Easy" Steps
- **Semantic HTML**
- ARIA attributes
- Keyboard navigation

</Layout>


<Notes>

So let's Start with Semantic HTML  

</Notes>

---

<Layout>

# [Semantic HTML](https://www.w3.org/TR/wai-aria-1.1/#dfn-semantics)
Provides your content and components with meaning beyond their visual representation.

</Layout>

<Notes>

- One of the things that is so powerful about HTML is that it was fundamentally designed and built to be accessible.
- Because of this we can rely on semantic HTML elements to do a lot of the heavy lifting.
- This is critical for building websites that can be understood by assistive technologies.
- Assistive technologies are just software and hardware, they only understand the code you write.
- So if we want these technologies to properly identify and interact with our components we have to speak their language

</Notes>

---

<CodeSurfer>

```jsx
<div 
  onClick={eventHandler}>
  This is a "button"
</div>
```

</CodeSurfer>

<Notes>

  - RAISE HANDS: how many of us have done something like this?
  - Unfortunately this is just a div with a click handler.
  - Assistive technologies like screen readers will have NO idea that this element even exists.
  - And users that navigate the web using only a keyboard won't even be able to interact with this element because it only has a click handler attached to it.

</Notes>

---

<CodeSurfer>

```jsx
<button onClick={eventHandler}>
  Fully accessible
</button>
```

</CodeSurfer>

<Notes>

  - If we were to use the HTML button element we would get all of that for free.
  - Assistive technologies understand what this is and know how to interact with it.
  - And it's fully interactive using only a keyboard.

</Notes>

---

<CodeSurferColumns themes={[ github, vsDark ]}>

<Step>

```jsx
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx
const Button = ({ 
  buttonContent = 'I just work!', 
  activate
}) => (
  <button onClick={activate}>
    {buttonContent}
  </button>
)
```

</Step>

</CodeSurferColumns>

<Notes>

  - And a lot of times it's just easier for us to use the semantic HTML elements than it is to try and jam accessibility support into a div.
  - We'll go over what some of this does later but for now just look at all of the code it takes to make a div button accessible vs. a regular button element.

</Notes>

---

<Layout>

# Semantic HTML
There are over 100 elements available in HTML.

</Layout>

<Notes>

- So use the tools that you have available to you.

</Notes>

---

<CodeSurfer>

```jsx
<div className="navBar">
  <span
    className="link"
    onClick={goSomewhere}>
      Fake link 1
  </span>
  <span 
    className="link"
    onClick={goSomewhere}>
      Fake link 2
  </span>
  <span 
    className="link"
    onClick={goSomewhere}>
      Fake link 3
  </span>
</div>
```

</CodeSurfer>

<Notes>
  - If you want to build a nav bar...
</Notes>

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <ul>
    <li>
      <a href="#">Real link 1</a>
    </li>
    <li>
      <a href="#">Real link 2</a>
    </li>
    <li>
      <a href="#">Real link 3</a>
    </li>
  </ul>
</nav>
```

</CodeSurfer>

<Notes>
  - use the nav element, list items and anchors for your markup
</Notes>

---

<CodeSurfer>

```jsx
<div className="table">
  <div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
    <div className="row">
      <span className="rowItem">üò∞</span>
      <span className="rowItem">üò∞</span>
    </div>
</div>
```

</CodeSurfer>

<Notes>
  - and instead of trying to reinvent the wheel by styling a table out of divs...
</Notes>

---

<CodeSurfer>

```jsx
<table>
  <tbody>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
      <tr>
        <td>üòá</td>
        <td>üòá</td>
      </tr>
    </tbody>
</table>
```

</CodeSurfer>

<Notes>
  
  - Use the table element and override the default styling
  - These elements were built with accessibility in mind and we should be leveraging them in the components we build whenever we can.

</Notes>

---

<Layout>

# Semantic HTML

</Layout>

<Notes>

- But of course... semantic HTML can't solve ALL of our accessibility problems

</Notes>

<!-- https://developer.mozilla.org/en-US/docs/Web/HTML/Element -->

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <dropdown>
    <a href="/about">About Page</a>
    <dropdownlist>
      <ul>
        <li>
          <a href="#">Real link 1</a>
        </li>
        <li>
          <a href="#">Real link 2</a>
        </li>
        <li>
          <a href="#">Real link 3</a>
        </li>
      </ul>
    </dropdownlist>
  </dropdown>
</nav>
```

</CodeSurfer>

<Notes>

- For example, it'd be GREAT if we could have something like this for when we want to build a nav bar that has a dropdown list in it.

</Notes>

---

<CodeSurfer>

```jsx 2,4,16,17
<nav className="navBar">
  <dropdown>
    <a href="/about">About Page</a>
    <dropdownlist>
      <ul>
        <li>
          <a href="#">Real link 1</a>
        </li>
        <li>
          <a href="#">Real link 2</a>
        </li>
        <li>
          <a href="#">Real link 3</a>
        </li>
      </ul>
    </dropdownlist>
  </dropdown>
</nav>
```

</CodeSurfer>

<Notes>

- Some kind of dropdown HTML elements based on common components like a dropdown list whose behavior would be managed by the browser would be amazing.
- And because it's a native HTML element, it would automatically be recognized by assistive technologies without any work on our part.

</Notes>

---

<CodeSurfer>

```jsx
<nav className="navBar">
  <a href="/about">About Page</a>
  <ul className="dropDownList hidden">
    <li>
      <a href="#">Real link 1</a>
    </li>
    <li>
      <a href="#">Real link 2</a>
    </li>
    <li>
      <a href="#">Real link 3</a>
    </li>
  </ul>
</nav>
```

</CodeSurfer>

<Notes>

- But that's not the world we live in.
- Instead we make all the magic happen with CSS and JS to get this to work the way we think a dropdown menu should.
- But of course, this component isn't accessible as is because no screen reader or other assistive tech is going to be able to identify it as a menu bar with dropdown menu items.
- So what we need is a way to assign semantic meaning to our elements and components so that assistive technologies can work with them.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- **ARIA attributes**
- Keyboard navigation

</Layout>

<Notes>
- And that's where ARIA attributes come in handy.
</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)
**A**ccessible **R**ich **I**nternet **A**pplications

</Layout>

<Notes>

- stands for accessible rich internet applications
- set of HTML attributes that help define the semantics of an element or component.
- attributes that are Understood by assistive technologies

</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul>
  <Appear>
      <li>roles</li>
      <li>states</li>
      <li>properties</li>
  </Appear>
</ul>

</Layout>

<Notes>

- ARIA attributes are broken up into three categories
- roles define the type of element or component
- states and properties are supportive attributes that can be used with roles.

</Notes>

---

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul>
  <li>roles</li>
  <li>states</li>
  <li>properties</li>
</ul>

</Layout>

<Notes>

- ARIA roles can be combined with states and properties and together they can be understood by assistive technologies so that they can announce them to the user.

</Notes>

---

<Image src={designPatternsIntro} />

<Notes>

- And a really helpful resource for figuring out which attributes do what is this design patterns and widgets section. 

</Notes>

---

<Image src={designPatternsIntro2} />

<Notes>

- It contains a list of common components that we're all familiar with.

</Notes>

---

<Image src={designPatternsIntro3} />

<Notes>

- And details what ARIA roles, states and properties are required and available to use for each component

</Notes>

---

<Image src={designPatternsMenuExample} />

<Notes>

- It also includes code samples in vanilla HTML, CSS and JS that we can use as our reference and translate to react.

</Notes>

---

<Layout>

# TL;DR ARIA [Button](https://www.w3.org/TR/wai-aria-practices/#wai-aria-roles-states-and-properties-3)

</Layout>

<Notes>

- So going off of the design pattern docs, let's break down the ARIA attributes our Button component needs

</Notes>

---

<CodeSurfer>

```jsx
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 17 title='add "button" ARIA role attribute'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- Here's our div button example from before.
- CODE TRANSITION
- We have to add in the button role so that assistive tech can identify this plain div as a button.
- Let's say we have a screen reader, it will announce that this element is a button and a user will know that they can interact with it.

</Notes>

---

<CodeSurfer>

```jsx 17 title='add "button" ARIA role attribute'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 3,18 title='add "aria-labelledby" or "aria-label" property'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- We also want to pass in a value for an accessible button label using the aria-label or aria-labelledby properties.
- Usually the screen reader will read the content inside of the button by default...
- But if we needed to override that value we could explicitly pass in what should be announced for this button.
- This is handy if we have button that have non-text content like images or icons.

</Notes>

---

<CodeSurfer>

```jsx 3,18 title='add "aria-labelledby" or "aria-label" property'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

```jsx 4,19 title='add "aria-disabled" state if button is inactive'
const Button = ({ 
  buttonContent = "So much work...", 
  accessibleLabel, 
  isDisabled = false, 
  activate 
}) => {
  
  const keyPressHandler = (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
      activate()
    }
  }

  return (
    <div
      tabindex="0"
      role="button"
      aria-label={accessibleLabel || buttonContent}
      aria-disabled={isDisabled ? 'true' : 'false'}
      onClick={activate}
      onKeyPress={keyPressHandler}>
      {buttonContent}
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- And lastly we have to make sure we signal to assistive tech when a button is inactive.
- We can do that by adding the aria-disabled state attribute and set it to true or false based on the button's inactive state.
- That's about it for ARIA attributes for our simple button

</Notes>

---

<Layout>

# TL;DR ARIA [Dialog](https://www.w3.org/TR/wai-aria-practices/#dialog_roles_states_props)(Modal)

</Layout>

<Notes>

- Here's another component that's listed in the design patterns documentation.

</Notes>

---

<CodeSurfer>

```jsx title='ARIA Modal'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 11 title='add "dialog" role to modal container'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- Let's take a look at the ARIA attributes we need to make our modal accessible.
- CODE TRANSITION
- our modal container needs the ARIA role attribute set to "dialog"

</Notes>

---

<CodeSurfer>

```jsx 11 title='add "dialog" role to modal container'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 12 title='set "aria-modal" state when active'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we need our assistive tech to know when our modal is open and active, we do that with the aria-modal state attribute.
- set that to true based on some component state.

</Notes>

---

<CodeSurfer>


```jsx 12 title='set "aria-modal" state when active'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

```jsx 2,13,14 title='"aria-label" or "aria-labelledby"'
const Modal = ({ 
  title,
  modalText
}) => {
  
  /* ... Some more code ... */

  return (
    <div
      className=`modalContainer ${isOpen ? '' : 'hidden'}`
      role="dialog"
      aria-modal={isOpen ? "true" : "false"}
      aria-labelledby="modalTitle">
        <h2 id="modalTitle">{title}</h2>
        <p className="modalContent">{modalText}</p>
      </div>
    </div>
  )
}
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we also have to provide an accessible label, so I'm using aria-labelledby property for that
- I set the value of it to the ID of an element that contains the modal title, that's my h2 here.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- **Keyboard navigation**

</Layout>

<Notes>

- all of our components have to support keyboard only navigation.

</Notes>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
How can a user interact with this component using only a keyboard?

</Layout>

<Notes>

- Not everyone interacts with the web with a mouse.
- We need to make sure that interactive elements can be accessed by a keyboard.

</Notes>

---

<Layout>

# Keyboard Navigation
We're responsible for managing keyboard navigation in our custom components

</Layout>

<Notes>

- When we consider how to manage keyboard navigation we have to think of them in terms of common conventions.

</Notes>

---

<Layout>

# Common Conventions
- `tab` and `shift+tab` move focus from one component to another
- arrows keys move focus from one interactive element to another _within_ a component 
- `Enter` and `Space` will activate an interactive element.

</Layout>

<!-- A primary keyboard navigation convention common across all platforms is that the tab and shift+tab keys move focus from one UI component to another while other keys, primarily the arrow keys, move focus inside of components that include multiple focusable elements. The path that the focus follows when pressing the tab key is known as the tab sequence or tab ring. -->

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Make sure your user knows where their keyboard focus is
<!-- When operating with a keyboard, two essentials of a good experience are the abilities to easily discern the location of the keyboard focus and to discover where focus landed after a navigation key has been pressed. The following factors affect to what extent a web page affords users these capabilities. -->

</Layout>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
- Make sure the focus indicator is always visible.

</Layout>

---

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
- Managing focus so that it persists between interaction events.

</Layout>

<Notes>

- If I open a modal by interacting with this button
- My focus is moved inside of the modal.  When I close the modal, what happens to my focus?
- It shouldn't just disappear or go back to the top of the page
- These should be as natural and predictable as possible.

</Notes>

---

<Layout>

# TL;DR
- Use common conventions for keyboard navigation.
- Keyboard focus indicator should always be visible.
- Focus should persist between interaction events.

</Layout>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- And those are the three main concepts we want to have in mind
- when we're building out our accessible components and reading up on the docs for how to do that

</Notes>

---

<Layout>

# [IRL Components](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#aria_ex)

</Layout>

<Notes>

- Where do we start when we're building our accessible components?
- Well, as we know the documentation can sometimes be a little hard to decipher and wordy

</Notes>

---

<Image src={designPatternsImage} alt="The W3C website Design Patterns Page"/>

<!-- how do you make this image component accessible with background image? -->

<Notes>

- BUT, there are some parts of the docs that are a bit easier to work with than others.
- the W3C org includes a list of common design patterns that we can reference and translate into our reusable components
- These are basically common components that we know and recognize, and they include mostly easy to digest requirements on how these components should behave.

</Notes>

---

<Layout>

# [`Alert`](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#alert)
An element that draws the user's attention to provide important information *without* interrupting the user from the current task.

</Layout>

<Notes>

- So let's start off with an easy example and try to build an Alert component

</Notes>

---

<Image src={alertDesignPattern} />

<Notes>

- If we take a look at the `Alert` design pattern...
- it includes a short-ish description on what an alert component is.

</Notes>

---

<Image src={alertExample1} />

<Notes>

- The expected keyboard interactions

</Notes>

---

<Image src={alertExample2} />

<Notes>

- And which ARIA attributes we should be using for our component.

</Notes>

---

<Image src={alertExample3} />

<Notes>

- And Usually a vanilla HTML, CSS and JS example of what the code could look like.

</Notes>

---

<Layout>

# TL;DR [`Alert`](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#alert)
- Should NOT affect keyboard focus
- ARIA [`role="alert"`](https://www.w3.org/TR/wai-aria-1.1/#alert)
- Should NOT disappear automatically*
- Screen reader only announces changes

</Layout>

<Notes>

- don't affect keyboard focus because it should not interrupt the user's task
- the alert should have role of alert so that the screen reader will know to announce it
- If you need them to disappear automatically then make the timeout long enough to give a person time to read.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- Let's break down this component using our three Easy steps

</Notes>

---

<CodeSurfer>

```jsx
const Alert = () => (
  <div className="container">

  </div>
)
```

</CodeSurfer>

<Notes>

- what semantic elements can we use in our alert
- Div provides no semantic value
- But all I want is a container

</Notes>

---

<CodeSurfer>

```jsx
const Alert = () => (
  <div className="container">
    <p className="message">This is really Important!</p>
  </div>
)
```

</CodeSurfer>

<Notes>

- Let's use a paragraph for the alert message

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- What aria elements do we need?

</Notes>

---

<CodeSurfer>

```jsx
const Alert = ({ alertMessage }) => (
  <div className="container" role="alert">
    <p className="message">{alertMessage}</p>
  </div>
)
```

</CodeSurfer>

<Notes>

- the docs told us that we need to add an aria role of alert.
- We want our components to be reusable and flexible so let's make the message dynamic.

</Notes>

---

<CodeSurfer>

```jsx
const Alert = ({ alertMessage = '' }) => (
  <div className="container" role="alert">
    <p className="message">{alertMessage}</p>
  </div>
)
```

</CodeSurfer>

<Notes>

- let's add a default value of an empty string.
- here's why this is really important

</Notes>

---

<Layout>

# TL;DR [`Alert`](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#alert)
- Should NOT affect keyboard focus
- ARIA `role="alert"`
- Should NOT disappear automatically*
- **Screen reader only announces changes**

</Layout>

<Notes>

- Our last requirement here says that screen readers will only announce changes to our alert component.
- What does this mean?


</Notes>

---

<Layout>

# **Screen reader only announces changes**
- Live regions have to be rendered on the page when it loads.

</Layout>

<Notes>

- alerts are known as live regions

</Notes>

---

<Layout>

# **Screen reader only announces changes**
- Live regions have to be rendered on the page when it loads.
- Add or change the message when screen reader should announce alert.

</Layout>

<Notes>

- you pass in the message to the alertMessage prop
- this will automatically render to the page, the screen reader will notice that there was a change in the element, and then announce that message.

</Notes>

---

<Layout>

# Three "Easy" Steps
- Semantic HTML
- ARIA attributes
- **Keyboard navigation**

</Layout>

<Notes>

- Now let's talk about keyboard nav.

</Notes>

---

<CodeSurfer>

```jsx
const Alert = ({ alertMessage = '' }) => (
  <div className="container" role="alert">
    <p className="message">{alertMessage}</p>
  </div>
)
```

</CodeSurfer>

<Notes>

- we don't have any interactive elements in our alert component right now and i think that's ok because if we remember our requirements we shouldn't be changing focus when this alert comes up.

</Notes>

---

<CodeSurfer>

```jsx
const Alert = ({ 
  alertMessage = '',
  closeHandler = defaultCloseHandler,
  closeMessage = 'Close' 
}) => (
  <div className="container" role="alert">
    <p className="message">
      {alertMessage}
    </p>
    <button 
      onClick={closeHandler}>
      {closeMessage}
    </button>
  </div>
)
```

</CodeSurfer>

<Notes>

- If we wanted to we could add a button as our interactive element
- this would automatically allow it to get keyboard focus and handle keyboard interactions
- but let's keep our alert as is without the button so that we can cover keyboard navigation a bit more in our next component.

</Notes>

---

<Layout>

# Recap

</Layout>

<Notes>

- We have to keep accessibility in mind when we're developing our apps and sites.
- In a sense, we're what could potentially stand in the way of keeping the web inclusive if we're alienating users with disabilities.
- But it's not always as easy as we hope it could be.
- Not many of us have a long history of learning or being taught accessibility concepts for web development.
- And when we try to venture out on our own docs can be hard to decipher, especially when we're first just starting out

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- But we can mitigate that by starting small.  Start with the building blocks.

</Notes>

---

<Layout>

# Accessible Components
- Semantic HTML
- ARIA attributes
- Keyboard navigation

</Layout>

<Notes>

- We can use semantic HTML to do a lot of the heavy lifting for us
- Where semantic HTML leaves gaps, identify the ARIA attributes that can help fill those in
- And make sure everything we build is interactive using only a keyboard.
- And once we have those things figured out we can take our building blocks and make them accessible.
- And use those to lay the foundations for fully accessible apps and websites.

</Notes>

---

<Layout>

# Thank You!

</Layout>


