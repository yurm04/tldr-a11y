import { Image } from 'mdx-deck'
import {
  CodeSurfer,
  CodeSurferColumns,
  Step,
} from "code-surfer";
import { vsDark, github, dracula } from "@code-surfer/themes";
import customTheme from './theme'

export const theme = customTheme;
import './styles.css'

import wcagDocsGif from './assets/wcagDocs.gif'
import designPatternsImage from './assets/designPatterns.png'
import alertDesignPattern from './assets/alertDesignPattern.png'
import alertExample1 from './assets/alertExample1.png'
import alertExample2 from './assets/alertExample2.png'
import alertExample3 from './assets/alertExample3.png'
import designPatternsIntro from './assets/designPatternsIntro.png'
import designPatternsIntro2 from './assets/designPatternsIntro2.png'
import designPatternsIntro3 from './assets/designPatternsIntro3.png'
import designPatternsMenuExample from './assets/designPatternsMenuExample.png'
import keyboardNav from './assets/keyboardNav.png'
import keyboardFocus1 from './assets/keyboardFocus1.gif'
import keyboardFocus2 from './assets/keyboardFocus2.gif'
import Layout from './components/Layout.js'

<Head>
  <title>TL;DR Accessible Components</title>
</Head>

<Layout>

# TL;DR Accessible Components

</Layout>

---

<Layout>

# Yuraima Estevez
- üë©‚Äçüíª Engineering Manager
- üì∞ The New York Times

</Layout>

<Notes>



</Notes>

---

<!-- intro -->

<Layout>

# What is accessibility?
Websites, tools and technologies that are **designed** and **developed** so that people with disabilities can use them.

</Layout>

<Notes>

- What does it mean for something to be accessible?

</Notes>

---

<!-- intro -->

<Layout>

# Why is accessibility important?

</Layout>

<Notes>

- There are several reasons why accessibility should be a priority for us as engineers.
- Of course there are monetary and legal reasons for why we should care about accessibility in our day-to-day
- But I want to focus on one reason in particular, because it's the one that resonates most with me and I hope it will with you too.

</Notes>

---

<!-- intro and morality -->

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>

<Notes>

- As engineers we have a lot of power in shaping the impact we have on our users at scale.
- All of us work at very different companies and across a multitude of industries.
- something seemingly small like a meme that doesn't have alternative text.
- or building an inaccessible checkout flow that makes it impossible for a screen reader user from buying groceries online.

</Notes>

---

<!-- intro and morality cont'd -->

<Layout>

>"The power of the Web is in its universality.  Access by everyone regardless of disability is an essential aspect."

*Tim Berners-Lee, W3C Director and inventor of the World Wide Web*

</Layout>


<Notes>

- We shouldn't be the ones gatekeeping and limiting access to the web.
- But when we aren't mindful of the code we're writing and the users that are impacted by it, that can sometimes be the result.
- Keeping the web universal and inclusive means we have to make our websites accessible.
- And to do that, we should start with the fundamentals.

</Notes>

---

<!-- discuss components -->

<Layout>

# Components
Encapsulated, reusable, and custom elements.

</Layout>

<Notes>

- Components are one of the things that make React so powerful.
- They allow us to package up functionality and UI and utilize them in various parts of our codebase.
- They're the building blocks of our apps and websites.
- and if the blocks are reliable and well-built it stands to reason that our apps will be too.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- So if we designed and developed the building blocks to be accessible,
- Then maybe we can start making significant progress in building fully accessible websites that work for everyone.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- Unfortunately that's easier said than done.
- When I first started learning accessibility concepts one of the hardest things to figure out was how I could take components I'd built dozens of times and uncover the requirements for making them accessible
- Naturally, I thought that turning to the documentation would help clear up my confusion, but instead I was hit with this...

</Notes>

---

<!-- Gif of WCAG huge wall of text -->

<Image src={wcagDocsGif} />

<Notes>

- A huge wall of text.
- Hundreds of links that go to even more documentation.
- And dozens of concepts that I didn't even know I didn't know.

</Notes>

---

<Layout>

# Accessible Components

</Layout>

<Notes>

- But that didn't get me off the hook, 
- I couldn't just brush accessibility under the rug.

</Notes>

---

<Layout>

# TL;DR
### Too Long; Didn't Read

</Layout>

<Notes>

- Instead I had to be more strategic about how I was approaching the documentation.

</Notes>

---

<Layout>

# TL;DR Accessible Components

</Layout>

<Notes>

- And that's what we're gonna be doing today during this talk.
- too long; didn't read approach to building accessible components.
- by going off of the documentation
- and quickly identifying the critical requirements necessary.

</Notes>

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

  <ul style={{ listStyle: 'none' }}>
    <Appear>
      <li>Semantic HTML</li>
      <li>ARIA attributes</li>
      <li>Keyboard navigation</li>
    </Appear>
  </ul>
  
</Layout>

<Notes>

- I've broken it down into 3 easy parts.
- NEXT: Use semantic HTML whenever possible.
- NEXT: Identify which ARIA attributes we need to add to those HTML elements.
- NEXT: And manage keyboard navigation.

</Notes>

<!-- https://www.w3.org/WAI/standards-guidelines/wcag/ -->

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

<ul style={{ listStyle: 'none' }}>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
</ul>

</Layout>

<Notes>

- "easy" in quotes.  there's a caveat.
- it takes time to build up your understanding of accessibility.
- NOT silver bullet life hack and not the ONLY things we need to consider.
- narrowing things down makes it easier and faster for us to ramp up and target exactly what we need to get up and running.

</Notes>

---

<!-- talk about what we're going over -->

<Layout>

# Three "Easy" Parts

<ul style={{ listStyle: 'none' }}>
    <li style={{ fontWeight: 'bold'}}>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
</ul>

</Layout>


<Notes>

So let's Start with Semantic HTML  

</Notes>

---

<!-- Start semantic HTML topic -->

<Layout>

# [Semantic HTML](https://www.w3.org/TR/wai-aria-1.1/#dfn-semantics)
Provides your content and components with meaning beyond their visual representation.

</Layout>

<Notes>

- HTML was fundamentally designed and built to be accessible.
- we can rely on semantic HTML elements to do a lot of the heavy lifting when building components.
- Assistive technologies are just software and hardware, they only understand the code you write.
- We have to speak their language, semantic HTML gets us there.

</Notes>

---

<!-- inaccessible button div component -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.0.js
```

</CodeSurfer>

<Notes>

  - We're all guilty of this.  Build a button, use a div.  Styling is easier.
  - Divs have no semantic meaning, Assistive technologies will have NO idea that this element even exists.
  - Keyboard only users won't be able to interact, because divs are not interactive by default.

</Notes>

---

<!-- accesible button component with button html element -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.1.js
```

</CodeSurfer>

<Notes>

  - Luckily there's an HTML element that represents a button.
  - Assistive technologies understand what this is and know how to interact with it.
  - And it's fully interactive using only a keyboard.

</Notes>

---

<!-- lots of html elements, all semantic -->

<Layout>

# Semantic HTML
There are over 100 elements available in HTML.

</Layout>

<Notes>

- over 100 elements.  almost all of them have some semantic meaning we can leverage.
- div and span are the only elements with no semantic meaning.
- So use the tools that you have available to you.

</Notes>

---

<!-- side by side button components -->

<CodeSurferColumns themes={[ github, vsDark ]}>

<Step>

```jsx file=./code/semantic-html-0.0.2.js
```

```jsx file=./code/semantic-html-0.0.3.js
```

</Step>

</CodeSurferColumns>

<Notes>

  - And a lot of times it's just easier for us to use the semantic HTML elements than it is to try and jam accessibility support into a div.
  - We'll go over what some of this does later but for now just look at all of the code it takes to make a div button accessible vs. a regular button element.

</Notes>

---

<!-- inaccessible nav bar -->
<CodeSurfer>

```jsx file=./code/semantic-html-0.0.4.js
```

</CodeSurfer>

<Notes>
  - If you want to build a nav bar...
</Notes>

---

<!-- accessible nav bar -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.5.js
```

</CodeSurfer>

<Notes>
  - use the nav element, list items and anchors for your markup
</Notes>

---

<!-- inaccessible table -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.6.js
```

</CodeSurfer>

<Notes>
  - and instead of trying to reinvent the wheel by styling a table out of divs...
</Notes>

---

<!-- accessible table -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.7.js
```

</CodeSurfer>

<Notes>
  
  - Use the table element and override the default styling
  - These elements were built with accessibility in mind and we should be leveraging them in the components we build whenever we can.

</Notes>

---

<!-- semantic html wrap up -->

<Layout>

# Semantic HTML

</Layout>

<Notes>

- But of course... semantic HTML can't solve ALL of our accessibility problems

</Notes>

<!-- https://developer.mozilla.org/en-US/docs/Web/HTML/Element -->

---

<!-- fake semantic html nav bar -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.8.js
```

```jsx 2,4,16,17 file=./code/semantic-html-0.0.8.js
```

</CodeSurfer>

<Notes>

- For example, it'd be GREAT if we could have something like this for when we want to build a nav bar that has a dropdown list in it.
- dropdown HTML elements whose behavior is managed entirely by the browser.
- And because it'd be a native HTML element, it would automatically be recognized by assistive technologies without any work on our part.

</Notes>

---

<!-- actual html nav bar -->

<CodeSurfer>

```jsx file=./code/semantic-html-0.0.9.js
```

</CodeSurfer>

<Notes>

- But that's not the world we live in.
- Instead we make all the magic happen with CSS and JS to get this to work the way we think a dropdown menu should.
- But of course, this component isn't accessible as is because no screen reader or other assistive tech is going to be able to identify it as a menu bar with dropdown menu items.
- So what we need is a way to assign semantic meaning to our elements and components so that assistive technologies can work with them.

</Notes>

---

<!-- moving on to aria attributes -->

<Layout>

# Three "Easy" Parts

<ul style={{ listStyle: 'none' }}>
    <li>Semantic HTML</li>
    <li style={{ fontWeight: 'bold'}}>ARIA attributes</li>
    <li>Keyboard navigation</li>
</ul>

</Layout>

<Notes>
- And that's where ARIA attributes come in handy.
</Notes>

---

<!-- what is aria 1 -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)
**A**ccessible **R**ich **I**nternet **A**pplications

</Layout>

<Notes>

- stands for accessible rich internet applications
- set of HTML attributes that help define the semantics of an element or component.
- So that they can be understood by assistive technologies

</Notes>

---

<!-- what is aria 2 -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul  style={{ listStyle: 'none' }}>
  <Appear>
      <li>roles</li>
      <li>states</li>
      <li>properties</li>
  </Appear>
</ul>

</Layout>

<Notes>

- ARIA attributes are broken up into three categories
- roles define the type of element or component
- states and properties are supportive attributes that can be used with roles.

</Notes>

---

<!-- aria - different kinds of attributes -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

<ul  style={{ listStyle: 'none' }}>
  <li>roles</li>
  <li>states</li>
  <li>properties</li>
</ul>

</Layout>

<Notes>

- ARIA roles can be combined with states and properties and together they can be understood by assistive technologies and properly communicated to the user.

</Notes>

---

<!-- WCAG design patterns -->

<Image src={designPatternsIntro} />

<Notes>

- And a really helpful resource for figuring out which attributes do what is this design patterns and widgets section. 

</Notes>

---

<!-- WCAG design patterns 2 -->

<Image src={designPatternsIntro2} />

<Notes>

- It contains a list of common components that we're all familiar with.

</Notes>

---

<!-- WCAG design patterns 3 -->

<Image src={designPatternsIntro3} />

<Notes>

- And details what ARIA roles, states and properties are required and available to use for each component

</Notes>

---

<!-- WCAG design patterns menu example-->

<Image src={designPatternsMenuExample} />

<Notes>

- It also includes code samples in vanilla HTML, CSS and JS that we can use as a reference when we're building our components in React.

</Notes>

---

<!-- aria button component -->

<Layout>

# TL;DR ARIA [Button](https://www.w3.org/TR/wai-aria-practices/#wai-aria-roles-states-and-properties-3)

</Layout>

<Notes>

- So going off of the design pattern docs, let's break down the ARIA attributes our Button component needs

</Notes>

---

<!-- aria warning -->

<Layout>

# üö® ARIA üö®
The best ARIA is no ARIA at all.

</Layout>

<Notes>

- But before we do that a quick warning, a general rule of thumb about aria is that the best aria is no aria at all.
- What that means is, if there are HTML elements that support what you're trying to do, use those instead of using ARIA.
- ARIA is incredibly powerful because it essentially overrides all the semantic meaning for the elements they're applied to. That means if they are used incorrectly, it could render your components completely useless to assistive tech, and create a terrible user experience.

</Notes>

---

<!-- aria button code 1 -->

<CodeSurfer>

```jsx file=./code/aria-0.0.0.js
```

```jsx 17 file=./code/aria-0.0.0.js title='add "button" ARIA role attribute'
```

</CodeSurfer>

<Notes>

- Here's our div button example from before.
- CODE TRANSITION
- We have to add in the button role so that assistive tech can identify this plain div as a button.
- Let's say we have a screen reader, it will announce that this element is a button and a user will know that they can interact with it.

</Notes>

---

<!-- aria button code 2 -->

<CodeSurfer>

```jsx 17 file=./code/aria-0.0.0.js title='add "button" ARIA role attribute'
```

```jsx 3,18 file=./code/aria-0.0.0.js title='add "aria-labelledby" or "aria-label" property'
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- We also want to pass in a value for an accessible button label using the aria-label or aria-labelledby properties.
- Usually the screen reader will read the content inside of the button by default...
- But if we needed to override that value we could explicitly pass in what should be announced for this button.
- This is handy if we have buttons that have non-text content like images or icons.

</Notes>

---

<!-- aria button code 3 -->

<CodeSurfer>

```jsx 3,18 file=./code/aria-0.0.0.js title='add "aria-labelledby" or "aria-label" property'
```

```jsx 4,19 file=./code/aria-0.0.0.js title='add "aria-disabled" state if button is inactive'
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- And lastly we have to make sure we signal to assistive tech when a button is inactive.
- We can do that by adding the aria-disabled state attribute and set it to true or false based on the button's inactive state.
- That's about it for ARIA attributes for our simple button

</Notes>

---

<!-- aria button code 4 -->

<Layout>

# TL;DR ARIA [Dialog](https://www.w3.org/TR/wai-aria-practices/#dialog_roles_states_props)(Modal)

</Layout>

<Notes>

- Here's another component that's listed in the design patterns documentation.

</Notes>

---

<!-- aria modal example -->

<CodeSurfer>

```jsx file=./code/aria-0.0.1.js title='ARIA Modal'
```

```jsx 11 file=./code/aria-0.0.1.js title='add "dialog" role to modal container'
```

</CodeSurfer>

<Notes>

- Let's take a look at the ARIA attributes we need to make our modal accessible.
- CODE TRANSITION
- our modal container needs the ARIA role attribute set to "dialog"

</Notes>

---

<!-- aria modal example 2 -->

<CodeSurfer>

```jsx 11 file=./code/aria-0.0.1.js title='add "dialog" role to modal container'
```

```jsx 12 file=./code/aria-0.0.1.js title='set "aria-modal" state when active'
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we need our assistive tech to know when our modal is open and active, we do that with the aria-modal state attribute.
- set that to true based on some component state.

</Notes>

---

<!-- aria modal example 3 -->

<CodeSurfer>


```jsx 12 file=./code/aria-0.0.1.js title='set "aria-modal" state when active'
```

```jsx 2,13,14 file=./code/aria-0.0.1.js title='"aria-label" or "aria-labelledby"'
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- we also have to provide an accessible label, so I'm using aria-labelledby property for that
- I set the value of it to the ID of an element that contains the modal title, that's my h2 here.
- And that's about it for a VERY simple accessible modal.

</Notes>

---

<!-- aria wrap up -->

<Layout>

# [ARIA Attributes](https://www.w3.org/TR/wai-aria-1.1/#usage)

</Layout>

<Notes>

- Now you probably noticed a very important characteristic about ARIA attribute through all of that.
- ARIA attributes function only as a way to communicate with assistive technologies like screen readers.
- What they DON'T do, is help with keyboard interactions.

</Notes>

---

<!-- keyboard nav intro -->

<Layout>

# Three "Easy" Parts

<ul style={{ listStyle: 'none' }}>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li  style={{ fontWeight: 'bold'}}>Keyboard navigation</li>
</ul>

</Layout>

<Notes>

- That's our third and last easy step.
- all of our components have to support keyboard only navigation.
- and that's because not everyone uses a mouse as their primary device for navigation.

</Notes>

---

<!-- keyboard nav intro 2 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
How can a user interact with our components using only a keyboard?

</Layout>

<Notes>

- Unless we're relying solely on semantic HTML elements, we're entirely responsible for managing keyboard navigation.
- So we need to consider how a user would be able to interact with our components using only a keyboard.

</Notes>

---

<!-- keyboard nav intro -->

<Image src={keyboardNav} />

<Notes>

- And this is another way the W3C docs makes it fairly easy to uncover these requirements.
- They have an entire section that explains how a component can be interacted with using only a keyboard.
- and this includes a list of which keys do what within the component.

</Notes>

---

<!-- button keyboard nav -->

<Layout>

# TL;DR [Button](https://www.w3.org/TR/wai-aria-practices/#keyboard-interaction-3) Keyboard Navigation

</Layout>

<Notes>

- Let's work through what the keyboard requirements are for one of our components

</Notes>

---

<!-- button keyboard nav code -->

<CodeSurfer>

```jsx file=./code/aria-0.0.0.js
```

```jsx 16 file=./code/aria-0.0.0.js title='add "tabindex" attribute'
```

</CodeSurfer>

<Notes>

- Here's our trusty div button that we've grown to love.
- our div element is not interactive by default, so the first thing to do is make sure we can tab to it and give it keyboard focus.
- CODE TRANSITION

</Notes>

---

<!-- button keyboard nav code 2 -->

<CodeSurfer>

```jsx 16 file=./code/aria-0.0.0.js title='add "tabindex" attribute'
```

</CodeSurfer>

<Notes>

- We can do that by adding the tabindex attribute to our button and setting it to "0"
- this will allow our div to gain keyboard focus when our user tabs to it.

</Notes>

---

<!-- button keyboard nav code 3 -->

<CodeSurfer>

```jsx 16 file=./code/aria-0.0.0.js title='add "tabindex" attribute'
```

```jsx 5,20 file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- We're passing an activate function to our button that we can trigger onClick...
- But we also need a way to trigger our activate function with a keyboard.

</Notes>

---

<!-- button keyboard nav code 4 -->

<CodeSurfer>

```jsx 5,20 file=./code/aria-0.0.0.js
```

```jsx 21 file=./code/aria-0.0.0.js title="add a keyboard event listener"
```

```jsx 8:12 file=./code/aria-0.0.0.js title='Listen for "Enter" and "Space"'
```

```jsx 10 file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- We're gonna add a key listener to our button, i'll use onKeyPress for this one.
- And we have to pass a handler function to it.  The docs say that our button can be activated using the ENTER and SPACE keys, so we're going to check for those keys being pressed.
- CODE TRANSITION
- And if they are, we'll go ahead and run that same activate function that we passed to the onClick event.

</Notes>

---

<!-- button keyboard nav code 5 -->

<CodeSurfer>

```jsx 10 file=./code/aria-0.0.0.js
```

```jsx file=./code/aria-0.0.0.js
```

</CodeSurfer>

<Notes>

- CODE TRANSITION
- And now we have a very simple div button that is keyboard accessible.

</Notes>

---

<!-- button keyboard nav code 6 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)

</Layout>

<Notes>

- There are a couple other considerations we should make when building up our component keyboard navigation

</Notes>

---

<!-- button keyboard nav code 7 -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Make sure your user knows where their keyboard focus is.

</Layout>

---

<!-- keyboard focus example -->

<Image src={keyboardFocus1} />

<Notes>

- That means we should make sure we always have some visible indicator for which elements currently have focus.
- At the very least that means that we shouldn't eliminate or change the focus outline on active elements.
- We also want to make sure that we're creating a predictable tab order so that our users can more or less know where their focus will go when they tab to the next or previous element.

</Notes>

---

<!-- manage focus -->

<Layout>

# [Keyboard Navigation](https://www.w3.org/TR/2019/NOTE-wai-aria-practices-1.1-20190814/#keyboard)
Manage focus so that it persists between interaction events.

</Layout>

---

<!-- modal example for focus -->

<Image src={keyboardFocus2} />

<Notes>

- So if we take a look at a modal example.
- When I key into the modal via my button, the keyboard focus moves into the modal to the interactive elements there.
- and when I close the modal, keyboard focus returns to the original activator button.
- It doesn't go to the top of the page or drop off completely.
- We need to make sure to manage this, especially because react makes it so easy to render and unmount components based on state.
- So persisting keyboard focus from state to state is key.

</Notes>

---

<!-- compare accessible button component to non -->

<CodeSurferColumns themes={[ github, vsDark ]}>

<Step>

```jsx file=./code/aria-0.0.0.js
```

```jsx file=./code/semantic-html-0.0.3.js
```

</Step>

</CodeSurferColumns>

<Notes>

  - And just to really drive the point home, let's take one last look at what it took for us to build our own accessible button.
  - When we consider how much extra code we had to write, the potential dangers with using ARIA attributes, and all the work needed to support keyboard navigation,
  - using the semantic HTML elements available to us becomes a no brainer
  - And that's a really easy place to start for anyone that's trying to figure out how they're going to convert they're huge component libraries and make them accessible.
  - Take the tiny step and find where you can use semantic HTML in a single component, and then go from there.

</Notes>

---

<!-- final recap -->

<Layout>

# Three "Easy" Parts

  <ul style={{ listStyle: 'none' }}>
    <Appear>
      <li>Semantic HTML</li>
      <li>ARIA attributes</li>
      <li>Keyboard navigation</li>
    </Appear>
  </ul>
  
</Layout>

<Notes>

- I kind of threw a lot at y'all so let's do a quick recap
- We have three steps that we should keep in mind when we're building our components.
- Use semantic HTML whenever possible.
- Identify which ARIA attributes we need to add to those HTML elements.
- And manage keyboard navigation.
- And we can uncover these requirements from the official docs once we know where to look and what we're looking for.

</Notes>

---

<!-- final recap 2 -->

<Layout>

# Three "Easy" Parts

  <ul style={{ listStyle: 'none' }}>
    <li>Semantic HTML</li>
    <li>ARIA attributes</li>
    <li>Keyboard navigation</li>
  </ul>
  
</Layout>

<Notes>

- And I want to reiterate that these are just techniques to hopefully make building accessible components easier.
- They are not the only things we have to consider.
- There are a lot of other factors to weight.
- things like...

</Notes>

---

<!-- other things to consider -->

<Layout>

# Accessible design
  
</Layout>

<Notes>

- Whether or not our visual design is accessible.
- Do we meet the requirements for color contrast.
- and are we making sure that we consider folks that are color blind when choosing our color schemes?

</Notes>

---

<!-- other things to consider 2 -->

<Layout>

# Accessible SPAs
  
</Layout>

<Notes>

- will our single page applications, that rely on javascript in the browser, still work if a user doesn't have javascript enabled?
- Have we worked out how navigation between pages using react router will affect screen readers and keyboard navigation?

</Notes>

---

<Layout>

# Testing accessibility
  
</Layout>

<Notes>

- Are we writing unit, integration and e2e tests that check to make sure we aren't breaking accessibility support with each change to our components?
- Can we automate accessibility testing and integrate it in our CI/CD pipelines so it's considered at every stage of the development cycle?
- And most importantly...

</Notes>

---

<!-- other things to consider 3 -->

<Layout>

# The user
  
</Layout>

<Notes>

- Are we considering our users?
- Sometimes as engineers it's hard to remember that we are not our users, and what may work for us or what we think makes the most sense to us, may not actually be what the user needs.

</Notes>

---

<!-- other things to consider 4 -->

<Layout>

# [The user](https://www.gatsbyjs.org/blog/2019-07-11-user-testing-accessible-client-routing/)
  
</Layout>

<Notes>

- There's an amazing post on the Gatsby blog, written by Marcy Sutton, that I encourage everyone to read.  She talks about how she led user testing at Gatsby to glimpse how users with disabilities navigate apps that have client-side routing.
- It's an incredible reminder that we can't always assume that we know what's best for our users, and we should try to involve them as much as possible when we're building out our components and sites.
- Let's always remember that our users are our #1 priority, and we should strive to keep the web inclusive and universal in order to do right by them.

</Notes>

---

<Layout>

# Thank You!

</Layout>


